---
# Allows you to add any config files in /usr/share/filebeat
# such as filebeat.yml
filebeatConfig:
  filebeat.yml: |
    # Create dynamic template avoiding extra default fields
    setup.template.enabled: true
    setup.template.name: "filebeat"
    setup.template.pattern: "filebeat-*"
    setup.template.overwrite: true
    # Create Lifecycle policies
    setup.ilm.enabled: true
    setup.ilm.pattern: "{now/d}-000001"
    filebeat.modules:
      - module: nginx
    filebeat.config.modules:
      # Glob pattern for configuration loading
      path: ${path.config}/modules.d/*.yml
    ## re-create index pipelines each restart
    filebeat.overwrite_pipelines: true
    filebeat.autodiscover:
      providers:
        - type: kubernetes
          templates:
            - condition.contains:
                kubernetes.labels.app: nginx-ingress
              config:
                - module: nginx
                  access:
                    input:
                      type: docker
                      containers.ids:
                        - "${data.kubernetes.container.id}"
            - condition.contains:
                kubernetes.labels.app: postgresql
              config:
                - module: postgresql
                  log:
                    input:
                      type: docker
                      containers.ids:
                        - "${data.kubernetes.container.id}"
            - condition:
                equals:
                  kubernetes.labels.log-type: "json"
              config:
                - type: docker
                  containers.ids:
                    - "${data.kubernetes.container.id}"
                  processors:
                    - decode_json_fields:
                        fields: ["message"]
                        target: ""
                        overwrite_keys: false
                        add_error_key: true
                    - rename:
                        fields:
                        - from: "file"
                          to: "filename"
  output.elasticsearch:
    hosts: '${ELASTICSEARCH_HOSTS:elasticsearch-master:9200}'

    module-nginx-access-ingest-default.json: |
      {
        "description": "Pipeline for parsing Nginx access logs. Requires the geoip and user_agent plugins.",
        "processors": [{
          "grok": {
            "field": "message",
            "patterns":[
              "\"?%{IP_LIST:nginx.access.remote_ip_list} - \\[%{IP_LIST:nginx.access.x_forwarded_for}\\] - %{DATA:nginx.access.user_name} \\[%{HTTPDATE:nginx.access.time}\\] \"%{GREEDYDATA:nginx.access.info}\" %{NUMBER:nginx.access.response_code} (?:%{NUMBER:nginx.access.body_sent.bytes}|-) (?:\"(?:%{DATA:nginx.access.referrer}|-)\") \"%{DATA:nginx.access.agent}\" %{NUMBER:nginx.access.request_length} %{NUMBER:nginx.access.response_time} %{DATA:nginx.access.upstream.proxy} %{NUMBER:nginx.access.upstream.bytes_sent} %{NUMBER:nginx.access.upstream.response_time} %{NUMBER:nginx.access.upstream.response}",
              "\"?%{IP_LIST:nginx.access.remote_ip_list} - %{DATA:nginx.access.user_name} \\[%{HTTPDATE:nginx.access.time}\\] \"%{GREEDYDATA:nginx.access.info}\" %{NUMBER:nginx.access.response_code} %{NUMBER:nginx.access.body_sent.bytes} \"%{DATA:nginx.access.referrer}\" \"%{DATA:nginx.access.agent}\""
              ],
            "pattern_definitions": {
              "IP_LIST": "%{IP}(\"?,?\\s*%{IP})*"
            },
            "ignore_missing": true
          }
        }, {
          "grok": {
            "field": "nginx.access.info",
            "patterns": [
                "%{WORD:nginx.access.method} %{DATA:nginx.access.url} HTTP/%{NUMBER:nginx.access.http_version}",
                ""
            ],
            "ignore_missing": true
          }
        }, {
          "remove": {
            "field": "nginx.access.info"
          }
        }, {
          "split": {
            "field": "nginx.access.remote_ip_list",
            "separator": "\"?,?\\s+"
          }
        }, {
          "script": {
            "lang": "painless",
            "inline": "boolean isPrivate(def ip) { try { StringTokenizer tok = new StringTokenizer(ip, '.'); int firstByte = Integer.parseInt(tok.nextToken());       int secondByte = Integer.parseInt(tok.nextToken());if (firstByte == 10) {         return true;       }       if (firstByte == 192 && secondByte == 168) {         return true;       }       if (firstByte == 172 && secondByte >= 16 && secondByte <= 31) {         return true;       }       if (firstByte == 127) {         return true;       }       return false;     } catch (Exception e) {       return false;     }   }   def found = false;   for (def item : ctx.nginx.access.remote_ip_list) {     if (!isPrivate(item)) {       ctx.nginx.access.remote_ip = item;       found = true;       break;     }   }   if (!found) {     ctx.nginx.access.remote_ip = ctx.nginx.access.remote_ip_list[0];   }"
            }
        }, {
          "rename": {
            "field": "@timestamp",
            "target_field": "read_timestamp"
          }
        }, {
          "date": {
            "field": "nginx.access.time",
            "target_field": "@timestamp",
            "formats": ["dd/MMM/YYYY:H:m:s Z"]
          }
        }, {
          "remove": {
            "field": "nginx.access.time"
          }
        }, {
          "user_agent": {
            "field": "nginx.access.agent",
            "target_field": "nginx.access.user_agent"
          }
        }, {
          "remove": {
            "field": "nginx.access.agent"
          }
        }, {
          "geoip": {
            "field": "nginx.access.remote_ip",
            "target_field": "nginx.access.geoip"
          }
        }],
        "on_failure" : [{
          "set" : {
            "field" : "error.message",
            "value" : "{{ _ingest.on_failure_message }}"
          }
        }]
      }
# Extra environment variables to append to the DaemonSet pod spec.
# This will be appended to the current 'env:' key. You can use any of the kubernetes env
# syntax here
extraEnvs: []
#  - name: MY_ENVIRONMENT_VAR
#    value: the_value_goes_here

extraVolumeMounts: |
  - name: filebeat-config
    mountPath: /usr/share/filebeat/module/nginx/access/ingest/default.json
    subPath: module-nginx-access-ingest-default.json
    readOnly: true

# Root directory where Filebeat will write data to in order to persist registry data across pod restarts (file position and other metadata).
hostPathRoot: /var/lib

image: "docker.elastic.co/beats/filebeat"
imageTag: "7.5.0"
imagePullPolicy: "IfNotPresent"
imagePullSecrets: []

livenessProbe:
  failureThreshold: 3
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5

readinessProbe:
  failureThreshold: 3
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5

# Whether this chart should self-manage its service account, role, and associated role binding.
managedServiceAccount: true

# additional labels
labels: {}

podAnnotations: {}
  # iam.amazonaws.com/role: es-cluster

# Various pod security context settings. Bear in mind that many of these have an impact on Filebeat functioning properly.
#
# - User that the container will execute as. Typically necessary to run as root (0) in order to properly collect host container logs.
# - Whether to execute the Filebeat containers as privileged containers. Typically not necessarily unless running within environments such as OpenShift.
podSecurityContext:
  runAsUser: 0
  privileged: false

resources:
  requests:
    cpu: "100m"
    memory: "100Mi"
  limits:
    cpu: "1000m"
    memory: "200Mi"

# Custom service account override that the pod will use
serviceAccount: ""

# A list of secrets and their paths to mount inside the pod
# This is useful for mounting certificates for security other sensitive values
secretMounts: []
#  - name: filebeat-certificates
#    secretName: filebeat-certificates
#    path: /usr/share/filebeat/certs

# How long to wait for Filebeat pods to stop gracefully
terminationGracePeriod: 30

tolerations: []

nodeSelector: {}

affinity: {}

# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
priorityClassName: ""

updateStrategy: RollingUpdate

# Override various naming aspects of this chart
# Only edit these if you know what you're doing
nameOverride: ""
fullnameOverride: ""
