---
# Allows you to add any config files in /usr/share/filebeat
# such as filebeat.yml
filebeatConfig:
  filebeat.yml: |
   # Create dynamic template avoiding extra default fields
   setup.template.enabled: true
   setup.template.name: "filebeat"
   setup.template.pattern: "filebeat-*"
   setup.template.overwrite: true
   # Create Lifecycle policies
   setup.ilm.enabled: true
   setup.ilm.pattern: "{now/d}-000001"
   filebeat.modules:
     - module: nginx
   filebeat.config.modules:
     # Glob pattern for configuration loading
     path: ${path.config}/modules.d/*.yml 
   ## re-create index pipelines each restart
   filebeat.overwrite_pipelines: true
   filebeat.autodiscover:
      providers:
        - type: kubernetes
          templates:
            - condition.contains:
                kubernetes.labels.app: nginx-ingress
              config:
                - module: nginx
                  access:
                    input:
                      type: docker
                      containers.ids:
                        - "${data.kubernetes.container.id}"
            - condition.contains:
                kubernetes.labels.app: postgresql
              config:
                - module: postgresql
                  log:
                    input:
                      type: docker
                      containers.ids:
                        - "${data.kubernetes.container.id}"
            - condition:
                equals:
                  kubernetes.labels.log-type: "json"
              config:
                - type: docker
                  containers.ids:
                    - "${data.kubernetes.container.id}"
                  processors:
                    - decode_json_fields:
                        fields: ["message"]
                        target: ""
                        overwrite_keys: false
                        add_error_key: true 
                    - rename:
                        fields:
                        - from: "file"
                          to: "filename"
   output.elasticsearch:
     hosts: '${ELASTICSEARCH_HOSTS:elasticsearch-master:9200}'

  module-nginx-access-ingest-default.json: |
    {
         "description": "Pipeline for parsing Nginx access logs. Requires the geoip and user_agent plugins.",
         "processors": [{
           "grok": {
             "field": "message",
             "patterns":[
               "\"?%{IP_LIST:nginx.access.remote_ip_list} - \\[%{IP_LIST:nginx.access.x_forwarded_for}\\] - %{DATA:nginx.access.user_name} \\[%{HTTPDATE:nginx.access.time}\\] \"%{GREEDYDATA:nginx.access.info}\" %{NUMBER:nginx.access.response_code} (?:%{NUMBER:nginx.access.body_sent.bytes}|-) (?:\"(?:%{DATA:nginx.access.referrer}|-)\") \"%{DATA:nginx.access.agent}\" %{NUMBER:nginx.access.request_length} %{NUMBER:nginx.access.response_time} %{DATA:nginx.access.upstream.proxy} %{NUMBER:nginx.access.upstream.bytes_sent} %{NUMBER:nginx.access.upstream.response_time} %{NUMBER:nginx.access.upstream.response}",
               "\"?%{IP_LIST:nginx.access.remote_ip_list} - %{DATA:nginx.access.user_name} \\[%{HTTPDATE:nginx.access.time}\\] \"%{GREEDYDATA:nginx.access.info}\" %{NUMBER:nginx.access.response_code} %{NUMBER:nginx.access.body_sent.bytes} \"%{DATA:nginx.access.referrer}\" \"%{DATA:nginx.access.agent}\""
               ],
             "pattern_definitions": {
               "IP_LIST": "%{IP}(\"?,?\\s*%{IP})*"
             },
             "ignore_missing": true
           }
         }, {
           "grok": {
             "field": "nginx.access.info",
             "patterns": [
                 "%{WORD:nginx.access.method} %{DATA:nginx.access.url} HTTP/%{NUMBER:nginx.access.http_version}",
                 ""
             ],
             "ignore_missing": true
           }
         }, {
           "remove": {
             "field": "nginx.access.info"
           }
         }, {
           "split": {
             "field": "nginx.access.remote_ip_list",
             "separator": "\"?,?\\s+"
           }
         }, {
           "script": {
             "lang": "painless",
             "inline": "boolean isPrivate(def ip) { try { StringTokenizer tok = new StringTokenizer(ip, '.'); int firstByte = Integer.parseInt(tok.nextToken());       int secondByte = Integer.parseInt(tok.nextToken());if (firstByte == 10) {         return true;       }       if (firstByte == 192 && secondByte == 168) {         return true;       }       if (firstByte == 172 && secondByte >= 16 && secondByte <= 31) {         return true;       }       if (firstByte == 127) {         return true;       }       return false;     } catch (Exception e) {       return false;     }   }   def found = false;   for (def item : ctx.nginx.access.remote_ip_list) {     if (!isPrivate(item)) {       ctx.nginx.access.remote_ip = item;       found = true;       break;     }   }   if (!found) {     ctx.nginx.access.remote_ip = ctx.nginx.access.remote_ip_list[0];   }"
             }
         }, {
           "rename": {
             "field": "@timestamp",
             "target_field": "read_timestamp"
           }
         }, {
           "date": {
             "field": "nginx.access.time",
             "target_field": "@timestamp",
             "formats": ["dd/MMM/YYYY:H:m:s Z"]
           }
         }, {
           "remove": {
             "field": "nginx.access.time"
           }
         }, {
           "user_agent": {
             "field": "nginx.access.agent",
             "target_field": "nginx.access.user_agent"
           }
         }, {
           "remove": {
             "field": "nginx.access.agent"
           }
         }, {
           "geoip": {
             "field": "nginx.access.remote_ip",
             "target_field": "nginx.access.geoip"
           }
         }],
         "on_failure" : [{
           "set" : {
             "field" : "error.message",
             "value" : "{{ _ingest.on_failure_message }}"
           }
         }]
       }
# Extra environment variables to append to the DaemonSet pod spec.
# This will be appended to the current 'env:' key. You can use any of the kubernetes env
# syntax here
extraEnvs: []
#  - name: MY_ENVIRONMENT_VAR
#    value: the_value_goes_here

extraVolumeMounts: |  
  - name: filebeat-config
    mountPath: /usr/share/filebeat/module/nginx/access/ingest/default.json
    subPath: module-nginx-access-ingest-default.json
    readOnly: true

# Root directory where Filebeat will write data to in order to persist registry data across pod restarts (file position and other metadata).
hostPathRoot: /var/lib

image: "docker.elastic.co/beats/filebeat"
imageTag: "7.5.0"
imagePullPolicy: "IfNotPresent"
imagePullSecrets: []

livenessProbe:
  failureThreshold: 3
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5

readinessProbe:
  failureThreshold: 3
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5

# Whether this chart should self-manage its service account, role, and associated role binding.
managedServiceAccount: true

# additionals labels
labels: {}

podAnnotations: {}
  # iam.amazonaws.com/role: es-cluster

# Various pod security context settings. Bear in mind that many of these have an impact on Filebeat functioning properly.
#
# - User that the container will execute as. Typically necessary to run as root (0) in order to properly collect host container logs.
# - Whether to execute the Filebeat containers as privileged containers. Typically not necessarily unless running within environments such as OpenShift.
podSecurityContext:
  runAsUser: 0
  privileged: false

resources:
  requests:
    cpu: "100m"
    memory: "100Mi"
  limits:
    cpu: "1000m"
    memory: "200Mi"

# Custom service account override that the pod will use
serviceAccount: ""

# A list of secrets and their paths to mount inside the pod
# This is useful for mounting certificates for security other sensitive values
secretMounts: []
#  - name: filebeat-certificates
#    secretName: filebeat-certificates
#    path: /usr/share/filebeat/certs

# How long to wait for Filebeat pods to stop gracefully
terminationGracePeriod: 30

tolerations: []

nodeSelector: {}

affinity: {}

# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
priorityClassName: ""

updateStrategy: RollingUpdate

# Override various naming aspects of this chart
# Only edit these if you know what you're doing
nameOverride: ""
fullnameOverride: ""
